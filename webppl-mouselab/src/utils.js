// Generated by CoffeeScript 1.12.3
(function() {
  var INITIAL_NODE, LRU, TERM_ACTION, TERM_STATE, UNKNOWN, _,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('lodash');

  LRU = require('lru-cache');

  TERM_ACTION = '__TERM_ACTION__';

  TERM_STATE = '__TERM_STATE__';

  UNKNOWN = '__';

  INITIAL_NODE = '';

  module.exports = {
    update: function(obj, key, val) {
      var o;
      o = {};
      o[key] = val;
      return _.extend({}, obj, o);
    },
    updateList: function(lst, idx, val) {
      lst = lst.slice();
      lst[idx] = val;
      return lst;
    },
    buildEnv: function(branch) {
      var actions, addNode, address2idx, belief, idx2address, initialState, layout, tree;
      branch = branch.concat([0]);
      actions = function(addr) {
        return '0123456789'.slice(0, branch[addr.length]);
      };
      belief = function(addr) {
        if (addr === '') {
          return 0;
        } else {
          return UNKNOWN;
        }
      };
      tree = [];
      initialState = [];
      idx2address = [];
      address2idx = {};
      layout = [];
      addNode = function(addr) {
        var a, children, idx, j, len, ref;
        address2idx[addr] = idx = tree.length;
        idx2address.push(addr);
        children = [];
        tree.push(children);
        initialState.push(belief(addr));
        ref = actions(addr);
        for (j = 0, len = ref.length; j < len; j++) {
          a = ref[j];
          children.push(addNode(addr + a));
        }
        return idx;
      };
      addNode('');
      return {
        initialState: initialState,
        tree: tree,
        idx2address: idx2address,
        address2idx: address2idx,
        hashState: function(state) {
          return state;
        }
      };
    },
    buildCross: function(branch, depth) {
      var env, hashCache;
      env = this.buildEnv([branch].concat(Array(depth - 1).fill(1)));
      hashCache = LRU(100000);
      env.hashState = function(state) {
        var s;
        if (state === TERM_STATE) {
          return state;
        } else {
          s = state;
          return [[s['0'], s['00'], s['000']].sort(), [s['1'], s['10'], s['100']].sort(), [s['2'], s['20'], s['200']].sort()].sort();
        }
      };
      return env;
    },
    firstUnobserved: function(acts) {
      var a, branch, depth, i, j, l, len, n, ref, ref1, result;
      depth = _.max((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = acts.length; j < len; j++) {
          a = acts[j];
          results.push(a.length);
        }
        return results;
      })());
      result = [];
      ref = '0123456789';
      for (j = 0, len = ref.length; j < len; j++) {
        branch = ref[j];
        for (i = l = 0, ref1 = depth; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
          n = branch + ('0'.repeat(i));
          if (indexOf.call(acts, n) >= 0) {
            result.push(n);
            break;
          }
        }
      }
      return result;
    },
    cache: function(f, env, maxSize) {
      var c, cf, usage;
      if (maxSize == null) {
        maxSize = null;
      }
      c = LRU(maxSize);
      usage = 0;
      cf = function(s, k, a) {
        var args, newk, stringedArgs;
        args = Array.prototype.slice.call(arguments, 3);
        stringedArgs = JSON.stringify([env.hashState(args[0])].concat(args.slice(1)));
        if (c.has(stringedArgs)) {
          usage += 1;
          return k(s, c.get(stringedArgs));
        } else {
          newk = function(s, r) {
            if (c.has(stringedArgs)) {
              console.log('Already in cache:', stringedArgs);
              if (JSON.stringify(c.get(stringedArgs)) !== JSON.stringify(r)) {
                console.log('OLD AND NEW CACHE VALUE DIFFER!');
                console.log('Old value:', c.get(stringedArgs));
                console.log('New value:', r);
              }
            }
            c.set(stringedArgs, r);
            return k(s, r);
          };
          return f.apply(this, [s, newk, a].concat(args));
        }
      };
      cf.cache = c;
      return cf;
    },
    cacheFred: function(f, maxSize) {
      var c, cf, usage;
      if (maxSize == null) {
        maxSize = null;
      }
      console.log('cacheFred');
      c = LRU(maxSize);
      usage = 0;
      cf = function(s, k, a) {
        var args, newk, stringedArgs;
        args = Array.prototype.slice.call(arguments, 3);
        stringedArgs = JSON.stringify(args);
        if (c.has(stringedArgs)) {
          usage += 1;
          return k(s, c.get(stringedArgs));
        } else {
          newk = function(s, r) {
            if (c.has(stringedArgs)) {
              console.log('Already in cache:', stringedArgs);
              if (JSON.stringify(c.get(stringedArgs)) !== JSON.stringify(r)) {
                console.log('OLD AND NEW CACHE VALUE DIFFER!');
                console.log('Old value:', c.get(stringedArgs));
                console.log('New value:', r);
              }
            }
            c.set(stringedArgs, r);
            return k(s, r);
          };
          return f.apply(this, [s, newk, a].concat(args));
        }
      };
      cf.cache = c;
      return cf;
    }
  };

}).call(this);
