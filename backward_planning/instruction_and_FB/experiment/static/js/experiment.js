// Generated by CoffeeScript 2.2.2
// coffeelint: disable=max_line_length, indentation
var BLOCKS, CONDITION, DEBUG, DEMO, DEMO_TRIALS, MIN_TIME, N_TRIAL, PARAMS, RETURN_BONUS, RETURN_TIME, SCORE, SHOW_PARTICIPANT, SHOW_PARTICIPANT_DATA, STAGE, STAGE1, STAGE2, STRUCTURE_TEST, STRUCTURE_TRAINING, TALK, TRIALS_TEST, TRIALS_TRAINING, calculateBonus, condition, createStartButton, delay, getTestTrials, getTrainingTrials, initializeExperiment, loadTimeout, principle_only, psiturk, saveData, slowLoad, with_demo, with_feedback, workerId;

BLOCKS = void 0;

TRIALS_TRAINING = void 0;

TRIALS_TEST = void 0;

DEMO_TRIALS = void 0;

STRUCTURE_TEST = void 0;

STRUCTURE_TRAINING = void 0;

N_TRIAL = void 0;

SCORE = 0;

calculateBonus = void 0;

getTrainingTrials = void 0;

getTestTrials = void 0;

DEBUG = false;

TALK = false;

SHOW_PARTICIPANT = false;

STAGE = 1;

STAGE1 = STAGE === 1;

STAGE2 = STAGE === 2;

RETURN_BONUS = 0;

if (DEBUG) {
  console.log("X X X X X X X X X X X X X X X X X\n X X X X X DEBUG  MODE X X X X X\nX X X X X X X X X X X X X X X X X");
  condition = 0;
  workerId = ['debugFRED'];
} else {
  console.log("# =============================== #\n# ========= NORMAL MODE ========= #\n# =============================== #");
}

if (mode === "{{ mode }}") {
  // Viewing experiment not through the PsiTurk server
  DEMO = true;
  condition = 2;
  workerId = ['debugFRED'];
}

// counterbalance = 0
CONDITION = parseInt(condition);

_.mapObject = mapObject;

//_.compose = _.flowRight
//SHOW_PARTICIPANT_DATA = '0/108'
SHOW_PARTICIPANT_DATA = false;

/*
All Mouselab-MDP trials will be demonstration trials
with data for the given participant. The coding is
CONDITION/PID and you can find the available codes
in exp1/static/json/data/1B.0/traces
*/
if (STAGE1) {
  with_feedback = CONDITION === 2;
  with_demo = CONDITION === 1;
  principle_only = CONDITION === 0;
  PARAMS = {
    feedback: with_feedback,
    demo: with_demo,
    principle_only: principle_only,
    inspectCost: 1,
    condition: condition,
    bonusRate: .002,
    delay_hours: 20,
    delay_window: 12,
    branching: '312',
    with_feedback: with_feedback,
    condition: CONDITION,
    startTime: Date(Date.now()),
    variance: '2_4_24',
    stage: 1
  };
}

if (STAGE2) {
  with_feedback = false;
  PARAMS = {
    feedback: 0,
    inspectCost: 1,
    bonusRate: .002,
    delay_hours: 24,
    delay_window: 12,
    branching: '31123',
    variance: '1_2_4_8_32',
    startTime: Date(Date.now()),
    stage: 2
  };
}

RETURN_TIME = new Date(getTime() + 1000 * 60 * 60 * PARAMS.delay_hours);

MIN_TIME = 7;

psiturk = new PsiTurk(uniqueId, adServerLoc, mode);

psiturk.recordUnstructuredData('condition', CONDITION);

psiturk.recordUnstructuredData('with_feedback', with_feedback);

psiturk.recordUnstructuredData('return_time', RETURN_TIME);

delay = function(time, func) {
  return setTimeout(func, time);
};

// $(window).resize -> checkWindowSize 920, 720, $('#jspsych-target')
// $(window).resize()
slowLoad = function() {
  var ref;
  return (ref = $('slow-load')) != null ? ref.show() : void 0;
};

loadTimeout = delay(12000, slowLoad);

createStartButton = function() {
  if (DEBUG) {
    initializeExperiment();
    return;
  }
  document.getElementById("loader").style.display = "none";
  document.getElementById("successLoad").style.display = "block";
  document.getElementById("failLoad").style.display = "none";
  return $('#load-btn').click(initializeExperiment);
};

saveData = function() {
  return new Promise(function(resolve, reject) {
    var timeout;
    timeout = delay(10000, function() {
      return reject('timeout');
    });
    return psiturk.saveData({
      error: function() {
        clearTimeout(timeout);
        console.log('Error saving data!');
        return reject('error');
      },
      success: function() {
        clearTimeout(timeout);
        console.log('Data saved to psiturk server.');
        return resolve();
      }
    });
  });
};

$(window).resize(function() {
  return checkWindowSize(800, 600, $('#jspsych-target'));
});

$(window).resize();

$(window).on('load', function() {
  // Load data and test connection to server.
  slowLoad = function() {
    var ref;
    return (ref = $('slow-load')) != null ? ref.show() : void 0;
  };
  loadTimeout = delay(12000, slowLoad);
  psiturk.preloadImages(['static/images/spider.png']);
  return delay(300, function() {
    var id;
    console.log('Loading data');
    psiturk.recordUnstructuredData('params', PARAMS);
    if (PARAMS.variance) {
      id = `${PARAMS.branching}_${PARAMS.variance}`;
    } else {
      id = `${PARAMS.branching}`;
    }
    STRUCTURE_TEST = loadJson("static/json/structure/31123.json");
    STRUCTURE_TRAINING = loadJson("static/json/structure/312.json");
    //TRIALS = loadJson "static/json/mcrl_trials/increasing.json"
    TRIALS_TEST = loadJson("static/json/rewards/31123_increasing1.json");
    console.log(`loaded ${(TRIALS_TEST != null ? TRIALS_TEST.length : void 0)} test trials`);
    TRIALS_TRAINING = loadJson("static/json/mcrl_trials/increasing.json");
    console.log(`loaded ${(TRIALS_TRAINING != null ? TRIALS_TRAINING.length : void 0)} training trials`);
    DEMO_TRIALS = _.shuffle(loadJson("static/json/demo/exp2_312_optimal.json"));
    console.log(`loaded ${(DEMO_TRIALS != null ? DEMO_TRIALS.length : void 0)} demo trials`);
    getTrainingTrials = (function() {
      var idx, t;
      t = _.shuffle(TRIALS_TRAINING);
      idx = 0;
      return function(n) {
        idx += n;
        return t.slice(idx - n, idx);
      };
    })();
    getTestTrials = (function() {
      var idx, t;
      t = _.shuffle(TRIALS_TEST);
      idx = 0;
      return function(n) {
        idx += n;
        return t.slice(idx - n, idx);
      };
    })();
    if (DEBUG || TALK) {
      createStartButton();
      return clearTimeout(loadTimeout);
    } else {
      console.log('Testing saveData');
      if (DEMO) {
        clearTimeout(loadTimeout);
        return delay(500, createStartButton);
      } else {
        return saveData().then(function() {
          clearTimeout(loadTimeout);
          return delay(500, createStartButton);
        }).catch(function() {
          clearTimeout(loadTimeout);
          return $('#data-error').show();
        });
      }
    }
  });
});

createStartButton = function() {
  if (DEBUG || TALK) {
    initializeExperiment();
    return;
  }
  if (DEMO) {
    $('#jspsych-target').append("<div class='alert alert-info'>\n  <h3>Demo mode</h3>\n\n  To go through the task as if you were a participant,\n  click <b>Begin</b> above.<br>\n  To view replays of the participants\n  in our study, click <b>View Replays</b> below.\n</div>\n<div class='center'>\n  <button class='btn btn-primary btn-lg centered' id=\"view-replays\">View Replays</button>\n</div>");
    $('#view-replays').click(function() {
      SHOW_PARTICIPANT = true;
      DEMO_TRIALS = _.shuffle(loadJson("static/json/demo/312.json"));
      return initializeExperiment();
    });
  }
  $('#load-icon').hide();
  $('#slow-load').hide();
  $('#success-load').show();
  return $('#load-btn').click(initializeExperiment);
};

initializeExperiment = function() {
  var Block, ButtonBlock, MouselabBlock, QuizLoop, TextBlock, ask_email, bonus_text, check_code, check_returning, demo, demo_basic1, demo_basic2, demo_basic3, demo_basic4, divider, divider_pretest_training, divider_training_test, experiment_timeline, finish, fullMessage, img, post_test, pre_test, pre_test_intro1, pre_test_intro2, principle1, principle2, principle3, principle4, principle5, prompt_resubmit, quiz, refresher1, refresher2, reprompt, reset_score, retention_instruction, save_data, talk_demo, test_block_intro, text, train_basic1, train_basic2, train_basic3, train_basic4, training, verbal_responses;
  $('#jspsych-target').html('');
  console.log('INITIALIZE EXPERIMENT');
  //  ======================== #
  //  ========= TEXT ========= #
  //  ======================== #

  // These functions will be executed by the jspsych plugin that
  // they are passed to. String interpolation will use the values
  // of global variables defined in this file at the time the function
  // is called.
  text = {
    debug: function() {
      if (DEBUG) {
        return "`DEBUG`";
      } else {
        return '';
      }
    },
    return_window: function() {
      var cutoff, tomorrow;
      cutoff = new Date(RETURN_TIME.getTime() + 1000 * 60 * 60 * PARAMS.delay_window);
      tomorrow = RETURN_TIME.getDate() > (new Date).getDate() ? 'tomorrow' : '';
      return `<b>${tomorrow}\nbetween ${format_time(RETURN_TIME)}\nand ${format_time(cutoff)}</b>`;
    },
    feedback: function() {
      if (STAGE2) {
        return [];
      } else {
        return "";
      }
    }
  };
  // ================================= #
  // ========= BLOCK CLASSES ========= #
  // ================================= #
  Block = class Block {
    constructor(config) {
      _.extend(this, config);
      this._block = this; // allows trial to access its containing block for tracking state
      if (this._init != null) {
        this._init();
      }
    }

  };
  TextBlock = (function() {
    class TextBlock extends Block {};

    TextBlock.prototype.type = 'text';

    TextBlock.prototype.cont_key = [];

    return TextBlock;

  }).call(this);
  ButtonBlock = (function() {
    class ButtonBlock extends Block {};

    ButtonBlock.prototype.type = 'button-response';

    ButtonBlock.prototype.is_html = true;

    ButtonBlock.prototype.choices = ['Continue'];

    ButtonBlock.prototype.button_html = '<button class="btn btn-primary btn-lg">%choice%</button>';

    return ButtonBlock;

  }).call(this);
  QuizLoop = class QuizLoop extends Block {
    loop_function(data) {
      var c, i, len, ref;
      console.log('data', data);
      ref = data[data.length].correct;
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        if (!c) {
          return true;
        }
      }
      return false;
    }

  };
  MouselabBlock = (function() {
    class MouselabBlock extends Block {};

    MouselabBlock.prototype.type = 'mouselab-mdp';

    MouselabBlock.prototype.playerImage = 'static/images/spider.png';

    // moveDelay: PARAMS.moveDelay
    // clickDelay: PARAMS.clickDelay
    // moveEnergy: PARAMS.moveEnergy
    // clickEnergy: PARAMS.clickEnergy
    MouselabBlock.prototype.lowerMessage = "<b>Clicking on a node reveals its value for a $1 fee.<br>\nMove with the arrow keys.</b>";

    return MouselabBlock;

  }).call(this);
  //_init: ->
  //_.extend(this, STRUCTURE)
  //  @trialCount = 0

  //  ============================== #
  //  ========= EXPERIMENT ========= #
  //  ============================== #
  img = function(name) {
    return `<img class='display' src='static/images/${name}.png'/>`;
  };
  QuizLoop = class QuizLoop extends Block {
    loop_function(data) {
      var c, i, len, ref;
      console.log('data', data);
      ref = data[data.length].correct;
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        if (!c) {
          return true;
        }
      }
      return false;
    }

  };
  // instruct_loop = new Block
  //   timeline: [instructions, quiz]
  //   loop_function: (data) ->
  //     for c in data[1].correct
  //       if not c
  //         return true  # try again
  //     psiturk.finishInstructions()
  //     psiturk.saveData()
  //     return false
  check_code = new Block({
    type: 'secret-code',
    code: 'elephant'
  });
  check_returning = (function() {
    var return_time, stage1, worker_id;
    console.log('worker', uniqueId);
    if (DEBUG) {
      worker_id = 'A13R19R7EQQNVA';
    } else {
      worker_id = uniqueId.split(':')[0];
    }
    stage1 = (loadJson('static/json/stage1.json'))[worker_id];
    RETURN_BONUS = stage1;
    if (stage1 != null) {
      console.log('stage1.return_time', stage1.return_time);
      return_time = new Date(stage1.return_time);
      console.log('return_time', return_time);
      if (true) { // getTime() > return_time   # TEMPORARY FIX
        // Redefine test trials to match breakdown established in stage 1.
        //TEST_TRIALS = (TRIALS[i] for i in stage1.test_idx)
        //SCORE += stage1.score
        return new Block({
          type: 'button-response',
          is_html: true,
          choices: ['Continue'],
          button_html: '<button id="return-continue" class="btn btn-primary btn-lg">%choice%</button>',
          stimulus: function() {
            return markdown("# Welcome back\n\nThanks for returning to complete Stage 2!\n\nIf you have already completed Stage 2 of this experiment earlier today, then please return this HIT. You cannot be paid for Stage 2 twice.\n\nAfter practicing on the simple version of Web of Cash in Stage 1, you can now use what you have learned to earn real money in the difficult version.\n\nBefore you begin, let us give you a brief refresher on how the game works.");
          }
        });
      } else {
        return new Block({
          type: 'text',
          cont_key: [null],
          text: function() {
            return markdown(`# Stage 2 not ready yet\n\nYou need to wait ${PARAMS.delay_hours} hours after completing Stage 1 before\nyou can begin Stage 2. You can begin the HIT at\n${format_time(return_time)} on ${format_date(return_time)}`);
          }
        });
      }
    } else {
      // **If you return the HIT, you may not be able to take it again later.**
      // Please leave the HIT open until it is time for you to complete Stage 2.
      return new Block({
        type: 'text',
        cont_key: [null],
        text: function() {
          return markdown("# Stage 1 not completed\n\nWe can't find you in our database. This is the second part of a two-part\nexperiment. If you did not complete the HIT \"Part 1 of two-part decision-making experiment\" yesterday, then please\nreturn this HIT. If you did complete it, please email\ncocosci.turk@gmail.com to report the error.");
        }
      });
    }
  })();
  retention_instruction = new Block({
    type: 'button-response',
    is_html: true,
    choices: ['Continue'],
    button_html: '<button class="btn btn-primary btn-lg">%choice%</button>',
    stimulus: function() {
      return markdown(`# You are beginning a two-stage experiment\n\nThis experiment has two stages which you will complete in separate HITs.\nThe total base payment for both HITs is $2.00.\n\nStage 1 takes about 5 minutes. Its base pay is only $0.20. But you will also earn a $0.55 bonus and it makes you eligible\nto participate in Stage 2 where you can earn $1.90 in 10 minutes plus a performance-dependent\nbonus of up to $3.50 ($1.30 is a typical bonus). \nYou will complete Stage 2 in a second HIT which you can begin ${text.return_window()}.\nIf you do not begin the HIT within this time frame, you lose the bonus from Stage 1 and will miss out on the\nmuch more lucrative second part of this experiment.           \n\nBy completing both stages, you can make up to\n$5.50, but if you don't complete Stage 2, you will lose your bonus from Stage 1 and the HIT would be a very bad deal for you.\n\n<div class="alert alert-warning">\n  Please do <b>NOT<b> continue unless you are certain that you will complete the second HIT which\n  which becomes available ${text.return_window()}. Completing only the first HIT would be a very bad deal for you (corresponding to a wage of $1.20/hour) and it would be bad for us too. You will be much better of if you complete both HITs (corresponding to a wage of about $15.20/hour.) and we need that for our experiment to work.\n</div>`);
    }
  });
  ask_email = new Block({
    type: 'survey-text',
    preamble: function() {
      return markdown(`# You've completed Stage 1\n\nSo far, you've earned a bonus of **$${calculateBonus().toFixed(2)}**.\nYou will receive this bonus, along with the additional bonus you earn \nin Stage 2 when you complete the second HIT. If you don't complete\nthe second HIT, you lose the bonus you have already earned.\n\nThe HIT for Stage 2 will have the title "Part 2 of two-part decision-making experiment"\nRemember, you must begin the HIT ${text.return_window()}.\n**Note:** The official base pay on mTurk will be $0.01;\nyou'll receive the $1.90 base pay for Stage 2 as part of your bonus \n(in addition to the bonus you earn).`);
    },
    questions: ['If you would like a reminder email, you can optionally enter it here.'],
    button: 'Submit HIT'
  });
  if (STAGE1) {
    finish = new Block({
      type: 'button-response',
      stimulus: function() {
        return markdown(`# You've completed Stage 1\n\nRemember to come back ${text.return_window()} to complete Stage 2.\nThe HIT will be titled "Part 2 of two-part decision-making\nexperiment". **Note:** The official base pay on mTurk will be $0.01;\nyou'll receive the $1.90 base pay for Stage 2 as part of your bonus \n(in addition to the bonus you earn).\n\nSo far, you've earned a bonus of **$${calculateBonus().toFixed(2)}**.\nYou will receive this bonus, along with the additional bonus you earn \nin Stage 2 when you complete the second HIT. If you don't complete\nthe second HIT, you give up the bonus you have already earned.`);
      },
      is_html: true,
      choices: ['Submit HIT'],
      button_html: '<button class="btn btn-primary btn-lg">%choice%</button>'
    });
  } else {
    finish = new Block({
      type: 'survey-text',
      preamble: function() {
        return markdown(`# You've completed the HIT\n\nThanks for participating. We hope you had fun! Based on your\nperformance in Stage 1 and Stage 2, you will be awarded a bonus of\n**$${calculateBonus().toFixed(2)}** on top of your base pay of $1.90.\n\nPlease briefly answer the questions below before you submit the HIT.`);
      },
      questions: ['How did you go about planning the route of the airplane?', 'Did you learn anything about how to plan better?', 'How old are you?', 'Which gender do you identify with?'],
      rows: [4, 4, 1, 1],
      button: 'Submit HIT'
    });
  }
  fullMessage = "";
  reset_score = new Block({
    type: 'call-function',
    func: function() {
      return SCORE = 0;
    }
  });
  divider = new TextBlock({
    text: function() {
      SCORE = 0;
      return "<div style='text-align: center;'> Press <code>space</code> to continue.</div>";
    }
  });
  divider_training_test = new TextBlock({
    text: function() {
      SCORE = 0;
      return "<div style='text-align: left;'> Congratulations! You have completed the training block. <br/> <br/> Press <code>space</code> to start the test block.</div>";
    }
  });
  test_block_intro = new TextBlock({
    text: function() {
      SCORE = 0;
      return markdown(` <h1>Test block</h1>\nWelcome to the test block! Here, you can use what you have learned to earn a bonus. Concretely, ${bonus_text('long')} <br/> To thank you for your work so far, we'll start you off with **$100**.\n Good luck! \n <div style='text-align: center;'> Press <code>space</code> to continue. </div>`);
    }
  });
  //divider_intro_training  = new TextBlock
  //    text: ->
  //      SCORE = 0
  //      "  <h1>Training</h1>  Congratulations! You have completed the instructions. Next, you will enter a training block where you can practice planning 10 times. After that, you will enter a test block where you can use what you have learned to earn a bonus. <br/> Press <code>space</code> to start the training block."
  divider_pretest_training = new TextBlock({
    text: function() {
      SCORE = 0;
      return "<h1>Training block</h1> <p> The game you just played is quite complex and it can be rather difficult to get it right. To help you master it, we will now let you practice on a simplified version of this game 10 times. </p> <p> In the simplified version your goal is to find the most profitable route of an airplane across a network of airports. There will be only three steps but otherwise the game works just like the one you just played. </p> <p>After that, there will be a test block where you can use what you have learned to earn a bonus. </p> <br/> Press <code>space</code> to start the training block.</div>";
    }
  });
  train_basic1 = new TextBlock({
    text: function() {
      SCORE = 0;
      return markdown("<h1> Practice makes perfect </h1>\n\nIn this HIT, you can try out and practice the goal-setting principle to make better decisions in a simple \ngame called *Flight Planning*. You will navigate an airplane across a network of airports (gray circles). The  value inside each circle shows you how profitable it is to fly there. When you land on a gray circle\n(a ***node***) the value of the node is added to your score.\n\nYou will be able to move the plane with the arrow keys, but only in the direction\nof the arrows between the nodes. The image below shows the network of airports.\n\n<img class='display' style=\"width:50%; height:auto\" src='static/images/web-of-cash-unrevealed.png'/>\n\n<div align=\"center\">Press <code>space</code> to proceed.</div>");
    }
  });
  train_basic2 = new TextBlock({
    text: function() {
      SCORE = 0;
      return markdown("<h1> Flight Planning </h1>\n\n<img class='display' style=\"width:50%; height:auto\" src='static/images/web-of-cash-revealed.png'/>\n\nThe flight planning game is a metaphor for life.    \nThe central circle that you start from represents your present circumstances. The six circles at the end of each path represent your possible futures. The circles in-between show the different paths you can take and how rewarding or unrewarding they are in the short-term.\n\nWhenever you move to the circle the value inside of it is added to your total score.        \n\n<div align=\"center\">Press <code>space</code> to proceed.</div>");
    }
  });
  train_basic3 = new TextBlock({
    text: function() {
      SCORE = 0;
      return markdown("   <h1> Node Inspector </h1>\n\n   Initially, all of the rewards will be hidden. It is hard to decide where to go when you don't know the rewards. Fortunately, you will have access to a ***node inspector*** which can reveal\n the value of a node. To use the node inspector, simply ***click on a node***. The image below illustrates how this works, and you can try this out on the **next** screen. \n\n **Note:** you can only use the node inspector when you're on the first\n node. \n\n<img class='display' style=\"width:50%; height:auto\" src='static/images/web-of-cash.png'/>\n\n One more thing: **You must spend *at least* 7 seconds on each round.**\n If you finish a round early, you'll have to wait until 7 seconds have\n passed.      \n");
    }
  });
  train_basic4 = new TextBlock({
    text: function() {
      SCORE = 0;
      return markdown("<h1> Practice the goal-setting principle </h1>\n\nWe will now let you practice applying the goal setting principle in the Flight Planning game. You will find that correctly applying this principle will give you the best possible results in this game.\n\nFurthermore, we will give you click-by-click feedback on whether you applied the goal setting principle correctly.\n\nAfter having practiced this principle 10 times you will hopefully be able to apply this principle to your own life if you want to.\n");
    }
  });
  demo_basic1 = new TextBlock({
    text: function() {
      SCORE = 0;
      return markdown("<h1> Application to Flight Planning </h1>\n\nIn this HIT, we will illustrate the goal-setting principle by applying it to a simple \ngame called *Flight Planning*. \n\nIn this game, the flight player navigates an airplane across a network of airports (gray circles). The  value inside each circle shows you how profitable it is to fly there. When you land on a gray circle\n(a ***node***) the value of the node is added to your score.\n\nThe player can move the plane with the arrow keys, but only in the direction\nof the arrows between the nodes. The image below shows the network of airports.\n\n<img class='display' style=\"width:50%; height:auto\" src='static/images/web-of-cash-unrevealed.png'/>\n\n<div align=\"center\">Press <code>space</code> to proceed.</div>");
    }
  });
  demo_basic2 = new TextBlock({
    text: function() {
      SCORE = 0;
      return markdown("<h1> Flight Planning </h1>\n\n<img class='display' style=\"width:50%; height:auto\" src='static/images/web-of-cash-revealed.png'/>\nThe flight planning game is a metaphor for life.    \nThe central circle that you start from represents your present circumstances. The six circles at the end of each path represent your possible futures. The circles in-between show the different paths you can take and how rewarding or unrewarding they are in the short-term.\n\nWhenever you make a move, the value inside the circle that you moved to is added to your total score.\n        \n\n<div align=\"center\">Press <code>space</code> to proceed.</div>");
    }
  });
  demo_basic3 = new TextBlock({
    text: function() {
      SCORE = 0;
      return markdown("   <h1> Node Inspector </h1>\n\n   Initially, all of the rewards will be hidden. It is hard to decide where to go when you don't know the rewards. Fortunately, the player can use a ***node inspector*** to reveal\n the value of a node. To use the node inspector, the player can simply ***click on a node***. The image below illustrates how this works. \n\n **Note:** you can only use the node inspector when you're on the first\n node. \n\n<img class='display' style=\"width:50%; height:auto\" src='static/images/web-of-cash.png'/>\n\n One more thing: **The player must spend *at least* 7 seconds on each round.**\n If they finish a round early, they have to wait until 7 seconds have\n passed.      \n");
    }
  });
  demo_basic4 = new TextBlock({
    text: function() {
      SCORE = 0;
      return markdown("<h1> Demonstration of the goal-setting principle </h1>\n\n Next, you will see a demonstration of the goal setting principle applied to the Flight Planning game. In this demonstration, you can watch what an optimal decision-maker would think about to figure out what to do. Concretely, you will see which nodes they would click on in which order, when they would stop thinking, and which actions they take based on the information they collected. </div>\n\nAfter having seen 10 demonstrations of this principle you will hopefully be able to apply this principle to your own life if you want to.\n\n<div align=\"center\">Press <code>space</code> to start the demonstration.");
    }
  });
  
  //lowerMessage: 'Move with the arrow keys.'
  //stateDisplay: 'never'
  //timeline: getTrials 0

  //   train_basic2 = new MouselabBlock
  //    blockName: 'train_basic2'
  //    stateDisplay: 'always'
  //    prompt: ->
  //      markdown """
  //      ## Some nodes are more important than others

  //{nodeValuesDescription} Please take a look at the example below to see what this means.

  //      Try a few more rounds now!
  //    """
  //    lowerMessage: 'Move with the arrow keys.'
  //    timeline: getTrials 5

  //  train_hidden = new MouselabBlock
  //    blockName: 'train_hidden'
  //    stateDisplay: 'never'
  //    prompt: ->
  //      markdown """
  //      ## Hidden Information

  //      Nice job! When you can see the values of each node, it's not too hard to
  //      take the best possible path. Unfortunately, you can't always see the
  //      value of the nodes. Without this information, it's hard to make good
  //      decisions. Try completing a few more rounds.
  //    """
  //    lowerMessage: 'Move with the arrow keys.'
  //    timeline: getTrials 5

  //  train_inspector = new MouselabBlock
  //    blockName: 'train_inspector'
  // special: 'trainClick'
  //    stateDisplay: 'click'
  //    stateClickCost: 0
  //    prompt: ->
  //      markdown """
  //      ## Node Inspector

  //      It's hard to make good decision when you can't see what you're doing!
  //      Fortunately, you have access to a ***node inspector*** which can reveal
  //      the value of a node. To use the node inspector, simply click on a node.
  //      **Note:** you can only use the node inspector when you're on the first
  //      node.

  //      Trying using the node inspector on a few nodes before making your first
  //      move.
  //    """
  //    # but the node inspector takes some time to work and you can only inspect one node at a time.
  //    timeline: getTrials 1
  // lowerMessage: "<b>Click on the nodes to reveal their values.<b>"

  //  train_inspect_cost = new MouselabBlock
  //    blockName: 'train_inspect_cost'
  //    stateDisplay: 'click'
  //    stateClickCost: PARAMS.inspectCost
  //    prompt: ->
  //      markdown """
  //      ## The price of information

  //      You can use node inspector to gain information and make better
  //      decisions. But, as always, there's a catch. Using the node inspector
  //      costs $#{PARAMS.inspectCost} per node. To maximize your score, you have
  //      to know when it's best to gather more information, and when it's time to
  //      act!
  //    """
  //    timeline: getTrials 1
  bonus_text = function(long) {
    var s;
    // if PARAMS.bonusRate isnt .01
    //   throw new Error('Incorrect bonus rate')
    s = "**you will earn 20 cent for every $100 you make in the game.**";
    if (long) {
      s += " For example, if your final score is $500, you will receive a bonus of $1.";
    }
    return s;
  };
  //  train_final = new MouselabBlock
  //    blockName: 'train_final'
  //    stateDisplay: 'click'
  //    stateClickCost: PARAMS.inspectCost
  //    prompt: ->
  //      markdown """
  //      ## Earn a Big Bonus

  //     Nice! You've learned how to play *Web of Cash*, and you're almost ready
  //      to play it for real. To make things more interesting, you will earn real
  //      money based on how well you play the game. Specifically,
  //      #{bonus_text('long')}

  //      These are the **final practice rounds** before your score starts counting
  //      towards your bonus.
  //    """
  //    lowerMessage: fullMessage
  //    timeline: getTrials 5

  //  train = new Block
  //    training: true
  //    timeline: [
  //      train_basic1
  //       divider    
  //      train_basic2    
  //      divider
  //      train_hidden
  //      divider
  //      train_inspector
  //       divider
  //      train_inspect_cost
  //      divider
  //       train_final
  //    ]
  quiz = new Block({
    preamble: function() {
      return markdown("# Quiz\n");
    },
    type: 'survey-multi-choice',
    questions: ["What is the range of node values in the first step?", "What is the range of node values in the last step?", "What is the cost of clicking?", "How much REAL money do you earn?"],
    options: [['$-4 to $4', '$-8 to $8', '$-48 to $48'], ['$-4 to $4', '$-8 to $8', '$-48 to $48'], ['$0', '$1', '$8', '$24'], ['1 cent for every $1 you make in the game', '1 cent for every $5 you make in the game', '5 cents for every $1 you make in the game', '5 cents for every $10 you make in the game']]
  });
  pre_test_intro1 = new TextBlock({
    text: function() {
      SCORE = 0;
      //prompt: ''
      //psiturk.finishInstructions()
      return markdown("## Node Inspector\n\nIt's hard to make good decision when you can't see what you will get!\nFortunately, you will have access to a ***node inspector*** which can reveal\nthe value of a node. To use the node inspector, simply ***click on a node***. The image below illustrates how this works, and you can try this out on the **next** screen. \n\n**Note:** you can only use the node inspector when you're on the first\nnode. \n\n<img class='display' style=\"width:50%; height:auto\" src='static/images/web-of-cash.png'/>\n\nOne more thing: **You must spend *at least* 7 seconds on each round.**\nIf you finish a round early, you'll have to wait until 7 seconds have\npassed.      \n\n<div align=\"center\"> Press <code>space</code> to continue. </div>\n");
    }
  });
  pre_test_intro2 = new TextBlock({
    text: function() {
      SCORE = 0;
      //prompt: ''
      //psiturk.finishInstructions()
      return markdown("## Get ready!\n\nYou are about to play your first round of Web of Cash. You will notice that the web used in this game is larger than the example you saw in the previous pictures. But that is the only difference, and everything else works as described. Good luck!\n\n<div align=\"center\"> Press <code>space</code> to continue. </div>\n");
    }
  });
  refresher1 = new TextBlock({
    text: function() {
      return markdown("  <h1> Refresher 1</h1>\n\n  In this HIT, you will play a game called *Web of Cash*. You will guide a\n  money-loving spider through a spider web. When you land on a gray circle\n  (a ***node***) the value of the node is added to your score.\n\n  You will be able to move the spider with the arrow keys, but only in the direction\n  of the arrows between the nodes. The image below shows the web that you will be navigating when the game starts.\n\n <img class='display' style=\"width:50%; height:auto\" src='static/images/web-of-cash-unrevealed.png'/>\n\n<div align=\"center\">Press <code>space</code> to proceed.</div>");
    }
  });
  refresher2 = new TextBlock({
    text: function() {
      return markdown("<h1> Refresher 2</h1>\n\nIt's hard to make good decision when you can't see what you will get!\nFortunately, you will have access to a ***node inspector*** which can reveal\nthe value of a node. To use the node inspector, simply ***click on a node***. The image below illustrates how this works, and you can try this out on the **next** screen. \n\n**Note:** you can only use the node inspector when you're on the first\nnode. \n\n<img class='display' style=\"width:50%; height:auto\" src='static/images/web-of-cash.png'/>\n\nOne more thing: **You must spend *at least* 7 seconds on each round.**\nIf you finish a round early, you'll have to wait until 7 seconds have\npassed.      \n\n<div align=\"center\"> Press <code>space</code> to continue. </div>\n");
    }
  });
  principle1 = new TextBlock({
    text: function() {
      return markdown("# A principle for making better decisions\n\nAs we go through our lives we are often drawn to immediate pleasures and avoid doing things that are unpleasant. For instance, we watch a Youtube video because it promises immediate fun, but we put off filing our taxes because that feels difficult.\n\nHighly successful people, like Elon Musk, make their decisions very differently: They **first think about all the things they could achieve in the long-term**, **pick one of them as their goal**, and then **do what it takes to get there** -- even if they are painful in the short-run. \n\n<div align=\"center\"> Press <code>space</code> to continue. </div>");
    }
  });
  principle2 = new TextBlock({
    text: function() {
      return markdown("# A principle for making better decisions\n\nYou too can apply this goal-setting principle to make better decisions. Here is how:\n<ol>    \n<li><b>Imagine what your life could be like in the future.</b> </li>\n<li><b>Choose which of those futures you want to create.</b></li>\n<li><b>Set yourself the goal to make that happen.</b></li>\n<li><b>Plan how to achieve the goal and act accordingly.</b></li>\n</ol>\n\n<div align=\"center\"> Press <code>space</code> to continue. </div>\n");
    }
  });
  principle3 = new Block({
    type: 'survey-text',
    preamble: function() {
      return markdown("# A principle for making better decisions\n");
    },
    questions: ['Please summarize the principle we just told you about in your own words.'],
    button: 'Next'
  });
  principle4 = new TextBlock({
    text: function() {
      return markdown("# A principle for making better decisions\n\nIf you had any difficulty remembering the principle, then please take another loook at it:\n<ol>    \n<li>Imagine what your life could be like in the future. </li>\n<li>Choose which of those futures you want to create.</li>\n<li>Set yourself the goal to make that happen.</li>\n<li>Plan how to achieve the goal and act accordingly.</li>\n</ol>\n\n<div align=\"center\"> Press <code>space</code> to continue. </div>");
    }
  });
  principle5 = new TextBlock({
    text: function() {
      return markdown("Now that you have learned about this principle, you can hopefully apply it to make better decisions in your own life if you want to.");
    }
  });
  pre_test = new MouselabBlock({
    minTime: 7,
    show_feedback: false,
    blockName: 'pre_test',
    stateDisplay: 'click',
    stateClickCost: PARAMS.inspectCost,
    timeline: (function() {
      switch (false) {
        case !SHOW_PARTICIPANT:
          return DEMO_TRIALS;
        case !DEBUG:
          return getTestTrials(1);
        default:
          return getTestTrials(1);
      }
    })(),
    startScore: 50,
    _init: function() {
      _.extend(this, STRUCTURE_TEST);
      return this.trialCount = 0;
    }
  });
  training = new MouselabBlock({
    minTime: 7,
    show_feedback: with_feedback,
    blockName: 'training',
    stateDisplay: 'click',
    stateClickCost: PARAMS.inspectCost,
    timeline: (function() {
      switch (false) {
        case !SHOW_PARTICIPANT:
          return DEMO_TRIALS;
        case !DEBUG:
          return getTrainingTrials(2);
        default:
          return getTrainingTrials(10);
      }
    })(),
    startScore: 50,
    _init: function() {
      _.extend(this, STRUCTURE_TRAINING);
      this.playerImage = 'static/images/plane.png';
      return this.trialCount = 0;
    }
  });
  demo = new MouselabBlock({
    minTime: 7,
    show_feedback: with_feedback,
    blockName: 'demo',
    stateDisplay: 'click',
    stateClickCost: PARAMS.inspectCost,
    timeline: DEMO_TRIALS.slice(0, 10),
    startScore: 50,
    _init: function() {
      _.extend(this, STRUCTURE_TRAINING);
      this.playerImage = 'static/images/plane.png';
      return this.trialCount = 0;
    }
  });
  post_test = new MouselabBlock({
    minTime: 7,
    show_feedback: false,
    blockName: 'test',
    stateDisplay: 'click',
    stateClickCost: PARAMS.inspectCost,
    timeline: (function() {
      switch (false) {
        case !SHOW_PARTICIPANT:
          return DEMO_TRIALS;
        case !DEBUG:
          return getTestTrials(10);
        default:
          return getTestTrials(20);
      }
    })(),
    startScore: 100,
    _init: function() {
      _.extend(this, STRUCTURE_TEST);
      return this.trialCount = 0;
    }
  });
  verbal_responses = new Block({
    type: 'survey-text',
    preamble: function() {
      return markdown("# Please answer these questions\n");
    },
    questions: ['How did you decide where to click?', 'How did you decide where NOT to click?', 'How did you decide when to stop clicking?', 'Where were you most likely to click at the beginning of each round?', 'Can you describe anything else about your strategy?'],
    button: 'Finish'
  });
  // TODO: ask about the cost of clicking
  finish = new Block({
    type: 'survey-text',
    preamble: function() {
      return markdown(`# You've completed the HIT\n\nThanks for participating. We hope you had fun! Based on your\nperformance, you will be awarded a bonus of\n**$${calculateBonus().toFixed(2)}**.\n\nPlease briefly answer the questions below before you submit the HIT.`);
    },
    questions: ['What did you learn?', 'Did you apply the principle in your own life? If so, which decision(s) did you use it for?', 'Was anything confusing or hard to understand?', 'What is your age?', 'Additional coments?'],
    button: 'Submit HIT'
  });
  talk_demo = new Block({
    timeline: [
      // new MouselabBlock
      //   lowerMessage: 'Move with the arrow keys.'
      //   stateDisplay: 'always'
      //   prompt: null
      //   stateClickCost: PARAMS.inspectCost
      //   timeline: getTrials 3
      divider,
      new MouselabBlock({
        stateDisplay: 'click',
        prompt: null,
        stateClickCost: PARAMS.inspectCost,
        timeline: getTestTrials(4)
      })
    ]
  });
  if (DEBUG) {
    experiment_timeline = (function() {
      var tl;
      //  return [demo]
      tl = [];
      if (STAGE1) {
        tl.push(retention_instruction);
      }
      if (STAGE2) {
        tl.push(check_returning);
        tl.push(refresher1);
        tl.push(refresher2);
      }
      //tl.push instruct_loop
      if (!STAGE2) {
        tl.push(principle1);
        tl.push(principle2);
        tl.push(principle3);
        tl.push(principle4);
        if (with_feedback) {
          tl.push(train_basic1);
          tl.push(train_basic2);
          tl.push(train_basic3);
          tl.push(train_basic4);
          //tl.push pre_test     
          //tl.push divider_pretest_training    
          tl.push(training);
        }
        if (with_demo) {
          tl.push(demo_basic1);
          tl.push(demo_basic2);
          tl.push(demo_basic3);
          tl.push(demo_basic4);
          tl.push(demo);
        }
        if (principle_only) {
          tl.push(principle5);
        }
      }
      if (!STAGE1) {
        tl.push(test_block_intro);
        tl.push(post_test);
      }
      if (STAGE1) {
        tl.push(ask_email);
      } else {
        tl.push(finish);
      }
      return tl;
    })();
  } else {
    experiment_timeline = (function() {
      var tl;
      //  return [demo]
      tl = [];
      if (STAGE1) {
        tl.push(retention_instruction);
      }
      if (STAGE2) {
        tl.push(check_returning);
        tl.push(refresher1);
        tl.push(refresher2);
      }
      //tl.push instruct_loop
      if (!STAGE2) {
        tl.push(principle1);
        tl.push(principle2);
        tl.push(principle3);
        tl.push(principle4);
        if (with_feedback) {
          tl.push(train_basic1);
          tl.push(train_basic2);
          tl.push(train_basic3);
          tl.push(train_basic4);
          //tl.push pre_test     
          //tl.push divider_pretest_training    
          tl.push(training);
        }
        if (with_demo) {
          tl.push(demo_basic1);
          tl.push(demo_basic2);
          tl.push(demo_basic3);
          tl.push(demo_basic4);
          tl.push(demo);
        }
        if (principle_only) {
          tl.push(principle5);
        }
      }
      if (!STAGE1) {
        tl.push(test_block_intro);
        tl.push(post_test);
      }
      if (STAGE1) {
        tl.push(ask_email);
      } else {
        tl.push(finish);
      }
      return tl;
    })();
  }
  calculateBonus = function() {
    var bonus;
    if (STAGE1) {
      bonus = 0.55; //SCORE * PARAMS.bonusRate
      bonus = (Math.round(bonus * 100)) / 100; // round to nearest cent
      return Math.max(0, bonus);
    }
    if (STAGE2) {
      bonus = 1.89 + SCORE * PARAMS.bonusRate + RETURN_BONUS;
      bonus = (Math.round(bonus * 100)) / 100; // round to nearest cent
      return Math.max(0, bonus);
    }
  };
  reprompt = null;
  save_data = function() {
    return psiturk.saveData({
      success: function() {
        console.log('Data saved to psiturk server.');
        if (reprompt != null) {
          window.clearInterval(reprompt);
        }
        return psiturk.computeBonus('compute_bonus', psiturk.completeHIT);
      },
      error: function() {
        return prompt_resubmit;
      }
    });
  };
  prompt_resubmit = function() {
    $('#jspsych-target').html("<h1>Oops!</h1>\n<p>\nSomething went wrong submitting your HIT.\nThis might happen if you lose your internet connection.\nPress the button to resubmit.\n</p>\n<button id=\"resubmit\">Resubmit</button>");
    return $('#resubmit').click(function() {
      $('#jspsych-target').html('Trying to resubmit...');
      reprompt = window.setTimeout(prompt_resubmit, 10000);
      return save_data();
    });
  };
  return jsPsych.init({
    display_element: $('#jspsych-target'),
    timeline: experiment_timeline,
    // show_progress_bar: true
    on_finish: function() {
      if (DEBUG) {
        return jsPsych.data.displayData();
      } else {
        psiturk.recordUnstructuredData('final_bonus', calculateBonus());
        return save_data();
      }
    },
    on_data_update: function(data) {
      console.log('data', data);
      return psiturk.recordTrialData(data);
    }
  });
};
